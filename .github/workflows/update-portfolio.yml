name: Update Portfolio Data

on:
  schedule:
    - cron: '0 6 * * *'  # Daily at 6 AM UTC
  workflow_dispatch:

jobs:
  update-portfolio:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      
    - uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Update portfolio data
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        node -e "
        const fs = require('fs');
        
        async function fetchWithAuth(url, token) {
          const response = await fetch(url, {
            headers: {
              'Authorization': 'token ' + token,
              'Accept': 'application/vnd.github.v3+json'
            }
          });
          return response.json();
        }
        
        function parseReadmeMetadata(readme) {
          if (!readme) return null;
          
          const metadata = {};
          const lines = readme.split('\\n');
          let inMetadataTable = false;
          
          console.log('Parsing README with ' + lines.length + ' lines');
          
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.includes('PROJECT METADATA') || line.includes('METADATA')) {
              inMetadataTable = true;
              console.log('Found metadata table at line ' + (i + 1) + ': ' + line.trim());
              continue;
            }
            
            if (inMetadataTable && (line.includes('===') || line.includes('**KEY FEATURES**'))) {
              console.log('End of metadata table at line ' + (i + 1) + ': ' + line.trim());
              break;
            }
            
            // Skip table separator line
            if (inMetadataTable && line.includes('---')) {
              console.log('Skipping table separator at line ' + (i + 1));
              continue;
            }
            
            if (inMetadataTable && line.includes('|') && line.includes('**')) {
              console.log('Processing metadata line ' + (i + 1) + ': ' + line.trim());
              const match = line.match(/\\|\\s*\\*\\*([^*]+)\\*\\*\\s*\\|\\s*([^|]+)\\s*\\|/);
              if (match) {
                const key = match[1].trim().toLowerCase();
                let value = match[2].trim();
                
                // Skip empty or placeholder values
                if (!value || value.startsWith('[') || value === 'none' || value === 'N/A' || value === '---') continue;
                
                console.log('Found metadata: ' + key + ' = ' + value);
                
                switch (key) {
                  case 'category': 
                    metadata.category = value; 
                    break;
                  case 'languages': 
                    metadata.languages = value.split('/').map(l => l.trim()).filter(l => l && !l.startsWith('[')); 
                    break;
                  case 'technologies': 
                    metadata.technologies = value.split('/').map(t => t.trim()).filter(t => t && !t.startsWith('[')); 
                    break;
                  case 'frameworks': 
                    metadata.frameworks = value.split('/').map(f => f.trim()).filter(f => f && !f.startsWith('[')); 
                    break;
                  case 'status': 
                    metadata.status = value; 
                    break;
                  case 'year': 
                    metadata.year = value; 
                    break;
                  case 'featured': 
                    metadata.featured = value.toLowerCase() === 'true'; 
                    break;
                  case 'hasdownload': 
                    console.log('Processing hasDownload: ' + value);
                    metadata.hasDownload = value.toLowerCase() === 'true'; 
                    break;
                  case 'downloadurl': 
                    console.log('Processing downloadUrl: ' + value);
                    if (value && !value.startsWith('[') && value !== 'none') metadata.downloadUrl = value; 
                    break;
                  case 'previewurl': 
                    console.log('Processing previewUrl: ' + value);
                    if (value && !value.startsWith('[') && value !== 'none') metadata.previewUrl = value; 
                    break;
                }
              }
            }
          }
          
          const result = Object.keys(metadata).length > 0 ? metadata : null;
          if (result) {
            console.log('Parsed metadata for repo: ' + JSON.stringify(result));
          }
          return result;
        }
        
        function categorizeRepository(repo) {
          return 'academic';
        }
        
        function extractTechnologies(repo) {
          // Only use as fallback if no README metadata exists
          return ['General'];
        }
        
        (async () => {
          try {
            console.log('=== STARTING PORTFOLIO UPDATE ===');
            const repos = await fetchWithAuth('https://api.github.com/users/NathanLCleary/repos?per_page=100&sort=updated', process.env.GITHUB_TOKEN);
            console.log('Fetched ' + repos.length + ' total repositories');
            
            const publicRepos = repos.filter(repo => !repo.fork && !repo.private && repo.name !== 'NathanLCleary.github.io');
            console.log('Filtered to ' + publicRepos.length + ' public repositories (excluding portfolio repo)');
            console.log('Repository names: ' + publicRepos.map(r => r.name).join(', '));
            
            const projects = [];
            
            for (let i = 0; i < publicRepos.length; i++) {
              const repo = publicRepos[i];
              console.log('\\n--- Processing Repository ' + (i + 1) + '/' + publicRepos.length + ': ' + repo.name + ' ---');
              console.log('Repo details: language=' + repo.language + ', stars=' + repo.stargazers_count + ', created=' + repo.created_at);
              
              let readme = null;
              try {
                const readmeData = await fetchWithAuth('https://api.github.com/repos/NathanLCleary/' + repo.name + '/readme', process.env.GITHUB_TOKEN);
                if (readmeData && readmeData.content && !readmeData.message) {
                  readme = Buffer.from(readmeData.content, 'base64').toString('utf-8');
                  console.log('Successfully read README for ' + repo.name);
                } else {
                  console.log('README not found or empty for ' + repo.name);
                }
              } catch (e) {
                console.log('Error fetching README for ' + repo.name + ': ' + e.message);
              }
              
              const metadata = parseReadmeMetadata(readme);
              if (metadata) {
                console.log('✓ Metadata found: ' + JSON.stringify(metadata, null, 2));
              } else {
                console.log('✗ No metadata found in README');
              }
              
              const project = {
                id: i + 1,
                title: (() => {
                  let title = repo.name.replace(/-/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());
                  if (title.includes('Iot')) title = title.replace('Iot', 'IoT');
                  if (title.includes('Api')) title = title.replace('Api', 'API');
                  if (title.includes('Sql')) title = title.replace('Sql', 'SQL');
                  if (title.includes('Ui')) title = title.replace('Ui', 'UI');
                  return title;
                })(),
                category: metadata?.category || 'Personal',
                description: repo.description || 'Professional software development project',
                languages: (metadata?.languages && metadata.languages.length > 0) ? metadata.languages : (() => {
                  let lang = repo.language?.toLowerCase() || 'javascript';
                  if (lang === 'jupyter notebook') lang = 'python';
                  return [lang];
                })(),
                technologies: (metadata?.technologies && metadata.technologies.length > 0) ? metadata.technologies : extractTechnologies(repo),
                frameworks: (metadata?.frameworks && metadata.frameworks.length > 0) ? metadata.frameworks : repo.topics || [],
                status: metadata?.status || 'Personal',
                year: metadata?.year || new Date(repo.created_at).getFullYear().toString(),
                githubUrl: repo.html_url,
                hasDownload: metadata?.hasDownload === true,
                featured: metadata?.featured === true || repo.stargazers_count > 3
              };
              
              console.log('Project created for ' + repo.name + ':');
              console.log('  - Category: ' + project.category + ' (from metadata: ' + (metadata?.category || 'none') + ')');
              console.log('  - Status: ' + project.status + ' (from metadata: ' + (metadata?.status || 'none') + ')');
              console.log('  - Languages: ' + JSON.stringify(project.languages) + ' (from metadata: ' + (JSON.stringify(metadata?.languages) || 'none') + ')');
              console.log('  - Technologies: ' + JSON.stringify(project.technologies) + ' (from metadata: ' + (JSON.stringify(metadata?.technologies) || 'none') + ')');
              console.log('  - HasDownload: ' + project.hasDownload + ' (from metadata: ' + metadata?.hasDownload + ')');
              console.log('  - Featured: ' + project.featured + ' (from metadata: ' + metadata?.featured + ')');
              
              // Handle download/preview URLs
              console.log('URL Processing for ' + repo.name + ':');
              console.log('  - hasDownload: ' + project.hasDownload);
              console.log('  - metadata.downloadUrl: ' + (metadata?.downloadUrl || 'none'));
              console.log('  - metadata.previewUrl: ' + (metadata?.previewUrl || 'none'));
              
              if (project.hasDownload) {
                if (metadata?.downloadUrl && metadata.downloadUrl !== 'none') {
                  console.log('  → Using downloadUrl: ' + metadata.downloadUrl);
                  if (metadata.downloadUrl.startsWith('http')) {
                    project.downloadUrl = metadata.downloadUrl;
                    console.log('  → Set downloadUrl as direct URL: ' + project.downloadUrl);
                  } else {
                    project.downloadUrl = repo.html_url + '/releases/latest';
                    console.log('  → Set downloadUrl as GitHub releases: ' + project.downloadUrl);
                  }
                }
                
                if (metadata?.previewUrl && metadata.previewUrl !== 'none') {
                  console.log('  → Using previewUrl: ' + metadata.previewUrl);
                  if (metadata.previewUrl.startsWith('http')) {
                    project.previewUrl = metadata.previewUrl;
                    console.log('  → Set previewUrl as direct URL: ' + project.previewUrl);
                  } else {
                    project.previewUrl = 'https://nathanlcleary.github.io/' + metadata.previewUrl;
                    console.log('  → Set previewUrl as GitHub Pages: ' + project.previewUrl);
                  }
                }
                
                // Fallback if hasDownload is true but no URLs provided
                if (!project.downloadUrl && !project.previewUrl) {
                  project.downloadUrl = repo.html_url + '/releases/latest';
                  console.log('  → Fallback to GitHub releases: ' + project.downloadUrl);
                }
              } else {
                console.log('  → No URLs (hasDownload is false)');
              }
              
              projects.push(project);
            }
            
            const currentFile = fs.readFileSync('js/projects.js', 'utf8');
            
            const newContent = currentFile.replace(
              /const projectsData = \\[[\\s\\S]*?\\];/,
              'const projectsData = ' + JSON.stringify(projects, null, 4) + ';'
            );
            
            fs.writeFileSync('js/projects.js', newContent);
            
            console.log('\\n=== PORTFOLIO UPDATE COMPLETE ===');
            console.log('Total projects processed: ' + projects.length);
            console.log('Projects with downloads:', projects.filter(p => p.hasDownload).map(p => p.title));
            console.log('Projects with downloadUrl:', projects.filter(p => p.downloadUrl).map(p => p.title + ': ' + p.downloadUrl));
            console.log('Projects with previewUrl:', projects.filter(p => p.previewUrl).map(p => p.title + ': ' + p.previewUrl));
            console.log('Updated portfolio with ' + projects.length + ' projects');
          } catch (error) {
            console.error('Error:', error);
            process.exit(1);
          }
        })();
        "
        
    - name: Commit changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add js/projects.js
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Auto-update portfolio data"
          git push
        fi