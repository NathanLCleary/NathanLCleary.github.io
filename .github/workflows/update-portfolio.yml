name: Update Portfolio Data

on:
  schedule:
    - cron: '0 6 * * *'  # Daily at 6 AM UTC
  workflow_dispatch:

jobs:
  update-portfolio:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      
    - uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Update portfolio data
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        node -e "
        const fs = require('fs');
        
        async function fetchWithAuth(url, token) {
          const response = await fetch(url, {
            headers: {
              'Authorization': \`token \${token}\`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });
          return response.json();
        }
        
        function parseReadmeMetadata(readme) {
          if (!readme) return null;
          
          const metadata = {};
          const lines = readme.split('\\n');
          let inMetadataTable = false;
          
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.includes('**PROJECT METADATA**') || line.includes('PROJECT METADATA')) {
              inMetadataTable = true;
              continue;
            }
            
            if (inMetadataTable && (line.includes('---') || line.includes('===') || line.includes('**KEY FEATURES**'))) {
              break;
            }
            
            if (inMetadataTable && line.includes('|') && line.includes('**')) {
              const match = line.match(/\\|\\s*\\*\\*([^*]+)\\*\\*\\s*\\|\\s*([^|]+)\\s*\\|/);
              if (match) {
                const key = match[1].trim().toLowerCase();
                let value = match[2].trim();
                
                // Skip empty or placeholder values
                if (!value || value.startsWith('[') || value === 'none' || value === 'N/A' || value === '---') continue;
                
                console.log(\`Found metadata: \${key} = \${value}\`);
                
                switch (key) {
                  case 'category': 
                    metadata.category = value; 
                    break;
                  case 'languages': 
                    metadata.languages = value.split('/').map(l => l.trim()).filter(l => l && !l.startsWith('[')); 
                    break;
                  case 'technologies': 
                    metadata.technologies = value.split('/').map(t => t.trim()).filter(t => t && !t.startsWith('[')); 
                    break;
                  case 'frameworks': 
                    metadata.frameworks = value.split('/').map(f => f.trim()).filter(f => f && !f.startsWith('[')); 
                    break;
                  case 'status': 
                    metadata.status = value; 
                    break;
                  case 'year': 
                    metadata.year = value; 
                    break;
                  case 'featured': 
                    metadata.featured = value.toLowerCase() === 'true'; 
                    break;
                  case 'hasdownload': 
                    metadata.hasDownload = value.toLowerCase() === 'true'; 
                    break;
                  case 'downloadurl': 
                    if (value && !value.startsWith('[') && value !== 'none') metadata.downloadUrl = value; 
                    break;
                  case 'previewurl': 
                    if (value && !value.startsWith('[') && value !== 'none') metadata.previewUrl = value; 
                    break;
                }
              }
            }
          }
          
          const result = Object.keys(metadata).length > 0 ? metadata : null;
          if (result) {
            console.log(\`Parsed metadata for repo: \${JSON.stringify(result)}\`);
          }
          return result;
        }
        
        function categorizeRepository(repo) {
          return 'academic';
        }
        
        function extractTechnologies(repo) {
          // Only use as fallback if no README metadata exists
          return ['General'];
        }
        
        (async () => {
          try {
            const repos = await fetchWithAuth('https://api.github.com/users/NathanLCleary/repos?per_page=100&sort=updated', process.env.GITHUB_TOKEN);
            const publicRepos = repos.filter(repo => !repo.fork && !repo.private && repo.name !== 'NathanLCleary.github.io');
            
            const projects = [];
            
            for (let i = 0; i < publicRepos.length; i++) {
              const repo = publicRepos[i];
              
              let readme = null;
              try {
                const readmeData = await fetchWithAuth(\`https://api.github.com/repos/NathanLCleary/\${repo.name}/readme\`, process.env.GITHUB_TOKEN);
                if (readmeData && readmeData.content && !readmeData.message) {
                  readme = Buffer.from(readmeData.content, 'base64').toString('utf-8');
                  console.log(\`Successfully read README for \${repo.name}\`);
                } else {
                  console.log(\`README not found or empty for \${repo.name}\`);
                }
              } catch (e) {
                console.log(\`Error fetching README for \${repo.name}: \${e.message}\`);
              }
              
              const metadata = parseReadmeMetadata(readme);
              
              const project = {
                id: i + 1,
                title: (() => {
                  let title = repo.name.replace(/-/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());
                  if (title.includes('Iot')) title = title.replace('Iot', 'IoT');
                  if (title.includes('Api')) title = title.replace('Api', 'API');
                  if (title.includes('Sql')) title = title.replace('Sql', 'SQL');
                  if (title.includes('Ui')) title = title.replace('Ui', 'UI');
                  return title;
                })(),
                category: metadata?.category || 'Personal',
                description: repo.description || 'Professional software development project',
                languages: (metadata?.languages && metadata.languages.length > 0) ? metadata.languages : (() => {
                  let lang = repo.language?.toLowerCase() || 'javascript';
                  if (lang === 'jupyter notebook') lang = 'python';
                  return [lang];
                })(),
                technologies: (metadata?.technologies && metadata.technologies.length > 0) ? metadata.technologies : extractTechnologies(repo),
                frameworks: (metadata?.frameworks && metadata.frameworks.length > 0) ? metadata.frameworks : repo.topics || [],
                status: metadata?.status || 'Personal',
                year: metadata?.year || new Date(repo.created_at).getFullYear().toString(),
                githubUrl: repo.html_url,
                hasDownload: metadata?.hasDownload === true,
                featured: metadata?.featured === true || repo.stargazers_count > 3
              };
              
              // Handle download/preview URLs
              if (project.hasDownload) {
                if (metadata?.downloadUrl && metadata.downloadUrl !== 'none') {
                  // App download link
                  if (metadata.downloadUrl.startsWith('http')) {
                    project.downloadUrl = metadata.downloadUrl;
                  } else {
                    project.downloadUrl = \`\${repo.html_url}/releases/latest\`;
                  }
                } else if (metadata?.previewUrl && metadata.previewUrl !== 'none') {
                  // Website preview link
                  if (metadata.previewUrl.startsWith('http')) {
                    project.downloadUrl = metadata.previewUrl;
                  } else {
                    // GitHub Pages URL
                    project.downloadUrl = \`https://nathanlcleary.github.io/\${metadata.previewUrl}\`;
                  }
                } else {
                  // Fallback to GitHub releases
                  project.downloadUrl = \`\${repo.html_url}/releases/latest\`;
                }
              }
              
              projects.push(project);
            }
            
            const currentFile = fs.readFileSync('js/projects.js', 'utf8');
            
            const newContent = currentFile.replace(
              /const projectsData = \[[\s\S]*?\];/,
              \`const projectsData = \${JSON.stringify(projects, null, 4)};\`
            );
            
            fs.writeFileSync('js/projects.js', newContent);
            
            console.log(\`Updated portfolio with \${projects.length} projects\`);
          } catch (error) {
            console.error('Error:', error);
            process.exit(1);
          }
        })();
        "
        
    - name: Commit changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add js/projects.js
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Auto-update portfolio data"
          git push
        fi